#include "sliding_mode.h"
#include "rtwtypes.h"
#include "mwmathutil.h"
#include <emmintrin.h>
#include "sliding_mode_private.h"
#include "rt_logging_mmi.h"
#include "sliding_mode_capi.h"
#include "sliding_mode_dt.h"
extern void * CreateDiagnosticAsVoidPtr_wrapper ( const char * id , int nargs
, ... ) ; RTWExtModeInfo * gblRTWExtModeInfo = NULL ; void
raccelForceExtModeShutdown ( boolean_T extModeStartPktReceived ) { if ( !
extModeStartPktReceived ) { boolean_T stopRequested = false ;
rtExtModeWaitForStartPkt ( gblRTWExtModeInfo , 3 , & stopRequested ) ; }
rtExtModeShutdown ( 3 ) ; }
#include "slsv_diagnostic_codegen_c_api.h"
#include "slsa_engine_exec.h"
#ifdef RSIM_WITH_SOLVER_MULTITASKING
boolean_T gbl_raccel_isMultitasking = 1 ;
#else
boolean_T gbl_raccel_isMultitasking = 0 ;
#endif
boolean_T gbl_raccel_tid01eq = 0 ; int_T gbl_raccel_NumST = 4 ; const char_T
* gbl_raccel_Version = "25.2 (R2025b) 28-Jul-2025" ; void
raccel_setup_MMIStateLog ( SimStruct * S ) {
#ifdef UseMMIDataLogging
rt_FillStateSigInfoFromMMI ( ssGetRTWLogInfo ( S ) , & ssGetErrorStatus ( S )
) ;
#else
UNUSED_PARAMETER ( S ) ;
#endif
} static DataMapInfo rt_dataMapInfo ; DataMapInfo * rt_dataMapInfoPtr = &
rt_dataMapInfo ; rtwCAPI_ModelMappingInfo * rt_modelMapInfoPtr = & ( rt_dataMapInfo . mmi ) ; int_T enableFcnCallFlag [ ] = { 1 , 1 , 1 , 1 } ; const char * raccelLoadInputsAndAperiodicHitTimes ( SimStruct * S , const char * inportFileName , int * matFileFormat ) { return rt_RAccelReadInportsMatFile ( S , inportFileName , matFileFormat ) ; }
#include "simstruc.h"
#include "fixedpoint.h"
#include "slsa_engine_exec.h"
#include "simtarget/slSimTgtSLExecSimBridge.h"
#define auwipyl1lw (-1)
B rtB ; X rtX ; DW rtDW ; static SimStruct model_S ; SimStruct * const rtS =
& model_S ; void rt_mldivide_U1d2x2_U2d2x1_Yd2x1_snf ( const real_T u0 [ 4 ]
, const real_T u1 [ 2 ] , real_T y [ 2 ] ) { real_T a21 ; int32_T r1 ;
int32_T r2 ; if ( muDoubleScalarAbs ( u0 [ 1 ] ) > muDoubleScalarAbs ( u0 [ 0
] ) ) { r1 = 1 ; r2 = 0 ; } else { r1 = 0 ; r2 = 1 ; } a21 = u0 [ r2 ] / u0 [
r1 ] ; y [ 1 ] = ( u1 [ r2 ] - u1 [ r1 ] * a21 ) / ( u0 [ r2 + 2 ] - u0 [ r1
+ 2 ] * a21 ) ; y [ 0 ] = ( u1 [ r1 ] - u0 [ r1 + 2 ] * y [ 1 ] ) / u0 [ r1 ]
; } void MdlInitialize ( void ) { rtDW . jizccaxfkn [ 0 ] = rtP .
Delay_InitialCondition ; rtX . ocjgzpkjel [ 0 ] = rtP .
VaryingStateSpace_InitialCondition ; rtDW . jizccaxfkn [ 1 ] = rtP .
Delay_InitialCondition ; rtX . ocjgzpkjel [ 1 ] = rtP .
VaryingStateSpace_InitialCondition ; rtDW . jizccaxfkn [ 2 ] = rtP .
Delay_InitialCondition ; rtX . ocjgzpkjel [ 2 ] = rtP .
VaryingStateSpace_InitialCondition ; rtDW . jizccaxfkn [ 3 ] = rtP .
Delay_InitialCondition ; rtX . ocjgzpkjel [ 3 ] = rtP .
VaryingStateSpace_InitialCondition ; rtDW . oslah5f3b3 = auwipyl1lw ; rtDW .
djuz2hac2i = auwipyl1lw ; } void MdlStart ( void ) { { bool
externalInputIsInDatasetFormat = false ; void * pISigstreamManager =
rt_GetISigstreamManager ( rtS ) ;
rtwISigstreamManagerGetInputIsInDatasetFormat ( pISigstreamManager , &
externalInputIsInDatasetFormat ) ; if ( externalInputIsInDatasetFormat ) { }
} MdlInitialize ( ) ; } void MdlOutputs ( int_T tid ) { __m128d tmp_c ;
__m128d tmp_f ; __m128d tmp_g ; __m128d tmp_j ; __m128d tmp_k ; real_T
ccm443rmyo [ 4 ] ; real_T tmp [ 2 ] ; real_T htdkb1aws5 ; real_T htdkb1aws5_p
; real_T tmp_e ; real_T tmp_i ; real_T tmp_m ; int32_T i ; int32_T i_p ;
int32_T tmp_p ; static const int8_T tmp_b [ 8 ] = { 0 , 10 , 0 , 3 , 0 , 21 ,
0 , - 6 } ; static const int8_T tmp_n [ 16 ] = { 0 , 0 , 0 , 0 , 1 , - 5 , 0
, 0 , 0 , 30 , 0 , - 3 , 0 , 0 , 1 , - 5 } ; if ( ssIsSampleHit ( rtS , 1 , 0
) ) { for ( i_p = 0 ; i_p < 8 ; i_p ++ ) { rtB . en3labafh0 [ i_p ] = tmp_b [
i_p ] ; } rtDW . oslah5f3b3 = auwipyl1lw ; for ( i_p = 0 ; i_p < 2 ; i_p ++ )
{ htdkb1aws5 = 0.0 ; htdkb1aws5_p = 0.0 ; for ( i = 0 ; i < 4 ; i ++ ) {
tmp_p = ( int32_T ) rtB . en3labafh0 [ ( i_p << 2 ) + i ] ; htdkb1aws5 += rtB
. luz5pmgfey [ i << 1 ] * ( real_T ) tmp_p ; htdkb1aws5_p += rtB . luz5pmgfey
[ ( i << 1 ) + 1 ] * ( real_T ) tmp_p ; } ccm443rmyo [ ( i_p << 1 ) + 1 ] =
htdkb1aws5_p ; ccm443rmyo [ i_p << 1 ] = htdkb1aws5 ; } } if ( ssIsSampleHit
( rtS , 2 , 0 ) ) { rtB . cvsh2wppvp [ 0 ] = rtDW . jizccaxfkn [ 0 ] ;
htdkb1aws5_p = rtP . Constant2_Value [ 0 ] - rtDW . jizccaxfkn [ 0 ] ; rtB .
cvsh2wppvp [ 1 ] = rtDW . jizccaxfkn [ 1 ] ; tmp_e = rtP . Constant2_Value [
1 ] - rtDW . jizccaxfkn [ 1 ] ; rtB . cvsh2wppvp [ 2 ] = rtDW . jizccaxfkn [
2 ] ; tmp_i = rtP . Constant2_Value [ 2 ] - rtDW . jizccaxfkn [ 2 ] ; rtB .
cvsh2wppvp [ 3 ] = rtDW . jizccaxfkn [ 3 ] ; tmp_m = rtP . Constant2_Value [
3 ] - rtDW . jizccaxfkn [ 3 ] ; for ( i_p = 0 ; i_p < 2 ; i_p ++ ) { rtB .
hxxlqejlqe [ i_p ] = muDoubleScalarTanh ( ( ( ( rtB . luz5pmgfey [ i_p + 2 ]
* tmp_e + rtB . luz5pmgfey [ i_p ] * htdkb1aws5_p ) + rtB . luz5pmgfey [ i_p
+ 4 ] * tmp_i ) + rtB . luz5pmgfey [ i_p + 6 ] * tmp_m ) / rtP .
SlidingModeControllerReachingLaw_Phi ) * - rtP .
SlidingModeControllerReachingLaw_ReachingRate ; } } if ( ssIsSampleHit ( rtS
, 1 , 0 ) ) { for ( i_p = 0 ; i_p < 16 ; i_p ++ ) { rtB . jbmxj2cv5i [ i_p ]
= tmp_n [ i_p ] ; } rtDW . djuz2hac2i = auwipyl1lw ; htdkb1aws5_p = 0.0 ;
tmp_e = 0.0 ; tmp_i = 0.0 ; tmp_m = 0.0 ; for ( i_p = 0 ; i_p < 4 ; i_p ++ )
{ htdkb1aws5 = rtB . cvsh2wppvp [ i_p ] ; htdkb1aws5_p += rtB . jbmxj2cv5i [
i_p << 2 ] * htdkb1aws5 ; tmp_e += rtB . jbmxj2cv5i [ ( i_p << 2 ) + 1 ] *
htdkb1aws5 ; tmp_i += rtB . jbmxj2cv5i [ ( i_p << 2 ) + 2 ] * htdkb1aws5 ;
tmp_m += rtB . jbmxj2cv5i [ ( i_p << 2 ) + 3 ] * htdkb1aws5 ; } for ( i_p = 0
; i_p <= 0 ; i_p += 2 ) { tmp_g = _mm_loadu_pd ( & rtB . luz5pmgfey [ i_p ] )
; tmp_j = _mm_loadu_pd ( & rtB . luz5pmgfey [ i_p + 2 ] ) ; tmp_f =
_mm_loadu_pd ( & rtB . luz5pmgfey [ i_p + 4 ] ) ; tmp_c = _mm_loadu_pd ( &
rtB . luz5pmgfey [ i_p + 6 ] ) ; tmp_k = _mm_loadu_pd ( & rtB . hxxlqejlqe [
i_p ] ) ; _mm_storeu_pd ( & tmp [ i_p ] , _mm_sub_pd ( _mm_add_pd ( _mm_add_pd
( _mm_add_pd ( _mm_mul_pd ( _mm_set1_pd ( 0.0 - htdkb1aws5_p ) , tmp_g ) ,
_mm_mul_pd ( tmp_j , _mm_set1_pd ( 0.0 - tmp_e ) ) ) , _mm_mul_pd ( tmp_f ,
_mm_set1_pd ( 0.0 - tmp_i ) ) ) , _mm_mul_pd ( tmp_c , _mm_set1_pd ( 0.0 -
tmp_m ) ) ) , tmp_k ) ) ; } rt_mldivide_U1d2x2_U2d2x1_Yd2x1_snf ( ccm443rmyo
, tmp , rtB . frltof5w1d ) ; htdkb1aws5_p = 0.0 ; tmp_e = 0.0 ; tmp_i = 0.0 ;
tmp_m = 0.0 ; for ( i_p = 0 ; i_p < 2 ; i_p ++ ) { htdkb1aws5 = rtB .
frltof5w1d [ i_p ] ; htdkb1aws5_p += rtP . Constant6_Value [ i_p << 2 ] *
htdkb1aws5 ; tmp_e += rtP . Constant6_Value [ ( i_p << 2 ) + 1 ] * htdkb1aws5
; tmp_i += rtP . Constant6_Value [ ( i_p << 2 ) + 2 ] * htdkb1aws5 ; tmp_m +=
rtP . Constant6_Value [ ( i_p << 2 ) + 3 ] * htdkb1aws5 ; } rtB . f05ndgvcfi
[ 3 ] = tmp_m ; rtB . f05ndgvcfi [ 2 ] = tmp_i ; rtB . f05ndgvcfi [ 1 ] =
tmp_e ; rtB . f05ndgvcfi [ 0 ] = htdkb1aws5_p ; } rtB . b5mch31ag1 [ 0 ] =
rtX . ocjgzpkjel [ 0 ] ; rtB . b5mch31ag1 [ 1 ] = rtX . ocjgzpkjel [ 1 ] ;
rtB . b5mch31ag1 [ 2 ] = rtX . ocjgzpkjel [ 2 ] ; rtB . b5mch31ag1 [ 3 ] =
rtX . ocjgzpkjel [ 3 ] ; htdkb1aws5 = rtB . b5mch31ag1 [ 1 ] ; htdkb1aws5_p =
rtB . b5mch31ag1 [ 0 ] ; tmp_e = rtB . b5mch31ag1 [ 2 ] ; tmp_i = rtB .
b5mch31ag1 [ 3 ] ; for ( i_p = 0 ; i_p <= 2 ; i_p += 2 ) { tmp_g =
_mm_loadu_pd ( & rtB . f05ndgvcfi [ i_p ] ) ; _mm_storeu_pd ( & rtB .
lyqikrix1a [ i_p ] , _mm_add_pd ( _mm_add_pd ( _mm_add_pd ( _mm_add_pd ( _mm_mul_pd ( _mm_loadu_pd ( & rtP . Constant5_Value [ i_p + 4 ] ) , _mm_set1_pd ( htdkb1aws5 ) ) , _mm_mul_pd ( _mm_loadu_pd ( & rtP . Constant5_Value [ i_p ] ) , _mm_set1_pd ( htdkb1aws5_p ) ) ) , _mm_mul_pd ( _mm_loadu_pd ( & rtP . Constant5_Value [ i_p + 8 ] ) , _mm_set1_pd ( tmp_e ) ) ) , _mm_mul_pd ( _mm_loadu_pd ( & rtP . Constant5_Value [ i_p + 12 ] ) , _mm_set1_pd ( tmp_i ) ) ) , tmp_g ) ) ; } htdkb1aws5_p = 0.0 ; tmp_e = 0.0 ; tmp_i = 0.0 ; tmp_m = 0.0 ; for ( i_p = 0 ; i_p < 4 ; i_p ++ ) { htdkb1aws5 = rtB . b5mch31ag1 [ i_p ] ; htdkb1aws5_p += rtB . jbmxj2cv5i [ i_p << 2 ] * htdkb1aws5 ; tmp_e += rtB . jbmxj2cv5i [ ( i_p << 2 ) + 1 ] * htdkb1aws5 ; tmp_i += rtB . jbmxj2cv5i [ ( i_p << 2 ) + 2 ] * htdkb1aws5 ; tmp_m += rtB . jbmxj2cv5i [ ( i_p << 2 ) + 3 ] * htdkb1aws5 ; } rtB . mgthgo0xnm [ 3 ] = tmp_m ; rtB . mgthgo0xnm [ 2 ] = tmp_i ; rtB . mgthgo0xnm [ 1 ] = tmp_e ; rtB . mgthgo0xnm [ 0 ] = htdkb1aws5_p ; if ( ssIsSampleHit ( rtS , 1 , 0 ) ) { htdkb1aws5_p = 0.0 ; tmp_e = 0.0 ; tmp_i = 0.0 ; tmp_m = 0.0 ; for ( i_p = 0 ; i_p < 2 ; i_p ++ ) { htdkb1aws5 = rtB . frltof5w1d [ i_p ] ; htdkb1aws5_p += rtB . en3labafh0 [ i_p << 2 ] * htdkb1aws5 ; tmp_e += rtB . en3labafh0 [ ( i_p << 2 ) + 1 ] * htdkb1aws5 ; tmp_i += rtB . en3labafh0 [ ( i_p << 2 ) + 2 ] * htdkb1aws5 ; tmp_m += rtB . en3labafh0 [ ( i_p << 2 ) + 3 ] * htdkb1aws5 ; } rtB . exm13eufw3 [ 3 ] = tmp_m ; rtB . exm13eufw3 [ 2 ] = tmp_i ; rtB . exm13eufw3 [ 1 ] = tmp_e ; rtB . exm13eufw3 [ 0 ] = htdkb1aws5_p ; } rtB . cr1f4lq33r [ 0 ] = rtB . exm13eufw3 [ 0 ] + rtB . mgthgo0xnm [ 0 ] ; rtB . cr1f4lq33r [ 1 ] = rtB . exm13eufw3 [ 1 ] + rtB . mgthgo0xnm [ 1 ] ; rtB . cr1f4lq33r [ 2 ] = rtB . exm13eufw3 [ 2 ] + rtB . mgthgo0xnm [ 2 ] ; rtB . cr1f4lq33r [ 3 ] = rtB . exm13eufw3 [ 3 ] + rtB . mgthgo0xnm [ 3 ] ; UNUSED_PARAMETER ( tid ) ; } void MdlOutputsTID3 ( int_T tid ) { int32_T i ; for ( i = 0 ; i < 4 ; i ++ ) { rtB . luz5pmgfey [ i << 1 ] = rtP . SlidingModeControllerReachingLaw_SlidingMatrix [ i ] ; rtB . luz5pmgfey [ ( i << 1 ) + 1 ] = rtP . SlidingModeControllerReachingLaw_SlidingMatrix [ i + 4 ] ; } UNUSED_PARAMETER ( tid ) ; } void MdlUpdate ( int_T tid ) { if ( ssIsSampleHit ( rtS , 2 , 0 ) ) { rtDW . jizccaxfkn [ 0 ] = rtB . lyqikrix1a [ 0 ] ; rtDW . jizccaxfkn [ 1 ] = rtB . lyqikrix1a [ 1 ] ; rtDW . jizccaxfkn [ 2 ] = rtB . lyqikrix1a [ 2 ] ; rtDW . jizccaxfkn [ 3 ] = rtB . lyqikrix1a [ 3 ] ; } UNUSED_PARAMETER ( tid ) ; } void MdlUpdateTID3 ( int_T tid ) { UNUSED_PARAMETER ( tid ) ; } void MdlDerivatives ( void ) { XDot * _rtXdot ; _rtXdot = ( ( XDot * ) ssGetdX ( rtS ) ) ; _rtXdot -> ocjgzpkjel [ 0 ] = rtB . cr1f4lq33r [ 0 ] ; _rtXdot -> ocjgzpkjel [ 1 ] = rtB . cr1f4lq33r [ 1 ] ; _rtXdot -> ocjgzpkjel [ 2 ] = rtB . cr1f4lq33r [ 2 ] ; _rtXdot -> ocjgzpkjel [ 3 ] = rtB . cr1f4lq33r [ 3 ] ; } void MdlProjection ( void ) { } void MdlTerminate ( void ) { } static void mr_sliding_mode_cacheDataAsMxArray ( mxArray * destArray , mwIndex i , int j , const void * srcData , size_t numBytes ) ; static void mr_sliding_mode_cacheDataAsMxArray ( mxArray * destArray , mwIndex i , int j , const void * srcData , size_t numBytes ) { mxArray * newArray = mxCreateUninitNumericMatrix ( ( size_t ) 1 , numBytes , mxUINT8_CLASS , mxREAL ) ; memcpy ( ( uint8_T * ) mxGetData ( newArray ) , ( const uint8_T * ) srcData , numBytes ) ; mxSetFieldByNumber ( destArray , i , j , newArray ) ; } static void mr_sliding_mode_restoreDataFromMxArray ( void * destData , const mxArray * srcArray , mwIndex i , int j , size_t numBytes ) ; static void mr_sliding_mode_restoreDataFromMxArray ( void * destData , const mxArray * srcArray , mwIndex i , int j , size_t numBytes ) { memcpy ( ( uint8_T * ) destData , ( const uint8_T * ) mxGetData ( mxGetFieldByNumber ( srcArray , i , j ) ) , numBytes ) ; } static void mr_sliding_mode_cacheBitFieldToMxArray ( mxArray * destArray , mwIndex i , int j , uint_T bitVal ) ; static void mr_sliding_mode_cacheBitFieldToMxArray ( mxArray * destArray , mwIndex i , int j , uint_T bitVal ) { mxSetFieldByNumber ( destArray , i , j , mxCreateDoubleScalar ( ( real_T ) bitVal ) ) ; } static uint_T mr_sliding_mode_extractBitFieldFromMxArray ( const mxArray * srcArray , mwIndex i , int j , uint_T numBits ) ; static uint_T mr_sliding_mode_extractBitFieldFromMxArray ( const mxArray * srcArray , mwIndex i , int j , uint_T numBits ) { const uint_T varVal = ( uint_T ) mxGetScalar ( mxGetFieldByNumber ( srcArray , i , j ) ) ; return varVal & ( ( 1u << numBits ) - 1u ) ; } static void mr_sliding_mode_cacheDataToMxArrayWithOffset ( mxArray * destArray , mwIndex i , int j , mwIndex offset , const void * srcData , size_t numBytes ) ; static void mr_sliding_mode_cacheDataToMxArrayWithOffset ( mxArray * destArray , mwIndex i , int j , mwIndex offset , const void * srcData , size_t numBytes ) { uint8_T * varData = ( uint8_T * ) mxGetData ( mxGetFieldByNumber ( destArray , i , j ) ) ; memcpy ( ( uint8_T * ) & varData [ offset * numBytes ] , ( const uint8_T * ) srcData , numBytes ) ; } static void mr_sliding_mode_restoreDataFromMxArrayWithOffset ( void * destData , const mxArray * srcArray , mwIndex i , int j , mwIndex offset , size_t numBytes ) ; static void mr_sliding_mode_restoreDataFromMxArrayWithOffset ( void * destData , const mxArray * srcArray , mwIndex i , int j , mwIndex offset , size_t numBytes ) { const uint8_T * varData = ( const uint8_T * ) mxGetData ( mxGetFieldByNumber ( srcArray , i , j ) ) ; memcpy ( ( uint8_T * ) destData , ( const uint8_T * ) & varData [ offset * numBytes ] , numBytes ) ; } static void mr_sliding_mode_cacheBitFieldToCellArrayWithOffset ( mxArray * destArray , mwIndex i , int j , mwIndex offset , uint_T fieldVal ) ; static void mr_sliding_mode_cacheBitFieldToCellArrayWithOffset ( mxArray * destArray , mwIndex i , int j , mwIndex offset , uint_T fieldVal ) { mxSetCell ( mxGetFieldByNumber ( destArray , i , j ) , offset , mxCreateDoubleScalar ( ( real_T ) fieldVal ) ) ; } static uint_T mr_sliding_mode_extractBitFieldFromCellArrayWithOffset ( const mxArray * srcArray , mwIndex i , int j , mwIndex offset , uint_T numBits ) ; static uint_T mr_sliding_mode_extractBitFieldFromCellArrayWithOffset ( const mxArray * srcArray , mwIndex i , int j , mwIndex offset , uint_T numBits ) { const uint_T fieldVal = ( uint_T ) mxGetScalar ( mxGetCell ( mxGetFieldByNumber ( srcArray , i , j ) , offset ) ) ; return fieldVal & ( ( 1u << numBits ) - 1u ) ; } mxArray * mr_sliding_mode_GetDWork ( ) { static const char_T * ssDWFieldNames [ 3 ] = { "rtB" , "rtDW" , "NULL_PrevZCX" , } ; mxArray * ssDW = mxCreateStructMatrix ( 1 , 1 , 3 , ssDWFieldNames ) ; mr_sliding_mode_cacheDataAsMxArray ( ssDW , 0 , 0 , ( const void * ) & ( rtB ) , sizeof ( rtB ) ) ; { static const char_T * rtdwDataFieldNames [ 5 ] = { "rtDW.jizccaxfkn" , "rtDW.oslah5f3b3" , "rtDW.djuz2hac2i" , "rtDW.hd5lfda2lr" , "rtDW.dl0lhrufxm" , } ; mxArray * rtdwData = mxCreateStructMatrix ( 1 , 1 , 5 , rtdwDataFieldNames ) ; mr_sliding_mode_cacheDataAsMxArray ( rtdwData , 0 , 0 , ( const void * ) & ( rtDW . jizccaxfkn ) , sizeof ( rtDW . jizccaxfkn ) ) ; mr_sliding_mode_cacheDataAsMxArray ( rtdwData , 0 , 1 , ( const void * ) & ( rtDW . oslah5f3b3 ) , sizeof ( rtDW . oslah5f3b3 ) ) ; mr_sliding_mode_cacheDataAsMxArray ( rtdwData , 0 , 2 , ( const void * ) & ( rtDW . djuz2hac2i ) , sizeof ( rtDW . djuz2hac2i ) ) ; mr_sliding_mode_cacheDataAsMxArray ( rtdwData , 0 , 3 , ( const void * ) & ( rtDW . hd5lfda2lr ) , sizeof ( rtDW . hd5lfda2lr ) ) ; mr_sliding_mode_cacheDataAsMxArray ( rtdwData , 0 , 4 , ( const void * ) & ( rtDW . dl0lhrufxm ) , sizeof ( rtDW . dl0lhrufxm ) ) ; mxSetFieldByNumber ( ssDW , 0 , 1 , rtdwData ) ; } return ssDW ; } void mr_sliding_mode_SetDWork ( const mxArray * ssDW ) { ( void ) ssDW ; mr_sliding_mode_restoreDataFromMxArray ( ( void * ) & ( rtB ) , ssDW , 0 , 0 , sizeof ( rtB ) ) ; { const mxArray * rtdwData = mxGetFieldByNumber ( ssDW , 0 , 1 ) ; mr_sliding_mode_restoreDataFromMxArray ( ( void * ) & ( rtDW . jizccaxfkn ) , rtdwData , 0 , 0 , sizeof ( rtDW . jizccaxfkn ) ) ; mr_sliding_mode_restoreDataFromMxArray ( ( void * ) & ( rtDW . oslah5f3b3 ) , rtdwData , 0 , 1 , sizeof ( rtDW . oslah5f3b3 ) ) ; mr_sliding_mode_restoreDataFromMxArray ( ( void * ) & ( rtDW . djuz2hac2i ) , rtdwData , 0 , 2 , sizeof ( rtDW . djuz2hac2i ) ) ; mr_sliding_mode_restoreDataFromMxArray ( ( void * ) & ( rtDW . hd5lfda2lr ) , rtdwData , 0 , 3 , sizeof ( rtDW . hd5lfda2lr ) ) ; mr_sliding_mode_restoreDataFromMxArray ( ( void * ) & ( rtDW . dl0lhrufxm ) , rtdwData , 0 , 4 , sizeof ( rtDW . dl0lhrufxm ) ) ; } } mxArray * mr_sliding_mode_GetSimStateDisallowedBlocks ( ) { mxArray * data = mxCreateCellMatrix ( 2 , 3 ) ; mwIndex subs [ 2 ] , offset ; { static const char_T * blockType [ 2 ] = { "Scope" , "Scope" , } ; static const char_T * blockPath [ 2 ] = { "sliding_mode/u" , "sliding_mode/y" , } ; static const int reason [ 2 ] = { 0 , 0 , } ; for ( subs [ 0 ] = 0 ; subs [ 0 ] < 2 ; ++ ( subs [ 0 ] ) ) { subs [ 1 ] = 0 ; offset = mxCalcSingleSubscript ( data , 2 , subs ) ; mxSetCell ( data , offset , mxCreateString ( blockType [ subs [ 0 ] ] ) ) ; subs [ 1 ] = 1 ; offset = mxCalcSingleSubscript ( data , 2 , subs ) ; mxSetCell ( data , offset , mxCreateString ( blockPath [ subs [ 0 ] ] ) ) ; subs [ 1 ] = 2 ; offset = mxCalcSingleSubscript ( data , 2 , subs ) ; mxSetCell ( data , offset , mxCreateDoubleScalar ( ( real_T ) reason [ subs [ 0 ] ] ) ) ; } } return data ; } void MdlInitializeSizes ( void ) { ssSetNumContStates ( rtS , 4 ) ; ssSetNumPeriodicContStates ( rtS , 0 ) ; ssSetNumY ( rtS , 0 ) ; ssSetNumU ( rtS , 0 ) ; ssSetDirectFeedThrough ( rtS , 0 ) ; ssSetNumSampleTimes ( rtS , 3 ) ; ssSetNumBlocks ( rtS , 33 ) ; ssSetNumBlockIO ( rtS , 12 ) ; ssSetNumBlockParams ( rtS , 41 ) ; } void MdlInitializeSampleTimes ( void ) { ssSetSampleTime ( rtS , 0 , 0.0 ) ; ssSetSampleTime ( rtS , 1 , 0.0 ) ; ssSetSampleTime ( rtS , 2 , 1.0 ) ; ssSetOffsetTime ( rtS , 0 , 0.0 ) ; ssSetOffsetTime ( rtS , 1 , 1.0 ) ; ssSetOffsetTime ( rtS , 2 , 0.0 ) ; } void raccel_set_checksum ( ) { ssSetChecksumVal ( rtS , 0 , 2096759775U ) ; ssSetChecksumVal ( rtS , 1 , 2439401993U ) ; ssSetChecksumVal ( rtS , 2 , 1016586332U ) ; ssSetChecksumVal ( rtS , 3 , 2257312720U ) ; }
#if defined(_MSC_VER)
#pragma optimize( "", off )
#endif
SimStruct * raccel_register_model ( ssExecutionInfo * executionInfo ) {
static struct _ssMdlInfo mdlInfo ; static struct _ssBlkInfo2 blkInfo2 ;
static struct _ssBlkInfoSLSize blkInfoSLSize ; rt_modelMapInfoPtr = & ( rt_dataMapInfo . mmi ) ; executionInfo -> gblObjects_ . numToFiles = 0 ; executionInfo -> gblObjects_ . numFrFiles = 0 ; executionInfo -> gblObjects_ . numFrWksBlocks = 0 ; executionInfo -> gblObjects_ . numModelInputs = 0 ; executionInfo -> gblObjects_ . numRootInportBlks = 0 ; executionInfo -> gblObjects_ . inportDataTypeIdx = NULL ; executionInfo -> gblObjects_ . inportDims = NULL ; executionInfo -> gblObjects_ . inportComplex = NULL ; executionInfo -> gblObjects_ . inportInterpoFlag = NULL ; executionInfo -> gblObjects_ . inportContinuous = NULL ; ( void ) memset ( ( char_T * ) rtS , 0 , sizeof ( SimStruct ) ) ; ( void ) memset ( ( char_T * ) & mdlInfo , 0 , sizeof ( struct _ssMdlInfo ) ) ; ( void ) memset ( ( char_T * ) & blkInfo2 , 0 , sizeof ( struct _ssBlkInfo2 ) ) ; ( void ) memset ( ( char_T * ) & blkInfoSLSize , 0 , sizeof ( struct _ssBlkInfoSLSize ) ) ; ssSetBlkInfo2Ptr ( rtS , & blkInfo2 ) ; ssSetBlkInfoSLSizePtr ( rtS , & blkInfoSLSize ) ; ssSetMdlInfoPtr ( rtS , & mdlInfo ) ; ssSetExecutionInfo ( rtS , executionInfo ) ; slsaAllocOPModelData ( rtS ) ; { static time_T mdlPeriod [ NSAMPLE_TIMES ] ; static time_T mdlOffset [ NSAMPLE_TIMES ] ; static time_T mdlTaskTimes [ NSAMPLE_TIMES ] ; static int_T mdlTsMap [ NSAMPLE_TIMES ] ; static int_T mdlSampleHits [ NSAMPLE_TIMES ] ; static boolean_T mdlTNextWasAdjustedPtr [ NSAMPLE_TIMES ] ; static int_T mdlPerTaskSampleHits [ NSAMPLE_TIMES * NSAMPLE_TIMES ] ; static time_T mdlTimeOfNextSampleHit [ NSAMPLE_TIMES ] ; { int_T i ; for ( i = 0 ; i < NSAMPLE_TIMES ; i ++ ) { mdlPeriod [ i ] = 0.0 ; mdlOffset [ i ] = 0.0 ; mdlTaskTimes [ i ] = 0.0 ; mdlTsMap [ i ] = i ; mdlSampleHits [ i ] = 1 ; } } ssSetSampleTimePtr ( rtS , & mdlPeriod [ 0 ] ) ; ssSetOffsetTimePtr ( rtS , & mdlOffset [ 0 ] ) ; ssSetSampleTimeTaskIDPtr ( rtS , & mdlTsMap [ 0 ] ) ; ssSetTPtr ( rtS , & mdlTaskTimes [ 0 ] ) ; ssSetSampleHitPtr ( rtS , & mdlSampleHits [ 0 ] ) ; ssSetTNextWasAdjustedPtr ( rtS , & mdlTNextWasAdjustedPtr [ 0 ] ) ; ssSetPerTaskSampleHitsPtr ( rtS , & mdlPerTaskSampleHits [ 0 ] ) ; ssSetTimeOfNextSampleHitPtr ( rtS , & mdlTimeOfNextSampleHit [ 0 ] ) ; } ssSetSolverMode ( rtS , SOLVER_MODE_SINGLETASKING ) ; { ssSetBlockIO ( rtS , ( ( void * ) & rtB ) ) ; ( void ) memset ( ( ( void * ) & rtB ) , 0 , sizeof ( B ) ) ; } { real_T * x = ( real_T * ) & rtX ; ssSetContStates ( rtS , x ) ; ( void ) memset ( ( void * ) x , 0 , sizeof ( X ) ) ; } { void * dwork = ( void * ) & rtDW ; ssSetRootDWork ( rtS , dwork ) ; ( void ) memset ( dwork , 0 , sizeof ( DW ) ) ; } { static DataTypeTransInfo dtInfo ; ( void ) memset ( ( char_T * ) & dtInfo , 0 , sizeof ( dtInfo ) ) ; ssSetModelMappingInfo ( rtS , & dtInfo ) ; dtInfo . numDataTypes = 23 ; dtInfo . dataTypeSizes = & rtDataTypeSizes [ 0 ] ; dtInfo . dataTypeNames = & rtDataTypeNames [ 0 ] ; dtInfo . BTransTable = & rtBTransTable ; dtInfo . PTransTable = & rtPTransTable ; dtInfo . dataTypeInfoTable = rtDataTypeInfoTable ; } sliding_mode_InitializeDataMapInfo ( ) ; ssSetIsRapidAcceleratorActive ( rtS , true ) ; ssSetRootSS ( rtS , rtS ) ; ssSetVersion ( rtS , SIMSTRUCT_VERSION_LEVEL2 ) ; ssSetModelName ( rtS , "sliding_mode" ) ; ssSetPath ( rtS , "sliding_mode" ) ; ssSetTStart ( rtS , 0.0 ) ; ssSetTFinal ( rtS , 50.0 ) ; { static RTWLogInfo rt_DataLoggingInfo ; rt_DataLoggingInfo . loggingInterval = ( NULL ) ; ssSetRTWLogInfo ( rtS , & rt_DataLoggingInfo ) ; } { { static int_T rt_LoggedStateWidths [ ] = { 4 , 4 } ; static int_T rt_LoggedStateNumDimensions [ ] = { 1 , 1 } ; static int_T rt_LoggedStateDimensions [ ] = { 4 , 4 } ; static boolean_T rt_LoggedStateIsVarDims [ ] = { 0 , 0 } ; static BuiltInDTypeId rt_LoggedStateDataTypeIds [ ] = { SS_DOUBLE , SS_DOUBLE } ; static int_T rt_LoggedStateComplexSignals [ ] = { 0 , 0 } ; static RTWPreprocessingFcnPtr rt_LoggingStatePreprocessingFcnPtrs [ ] = { ( NULL ) , ( NULL ) } ; static const char_T * rt_LoggedStateLabels [ ] = { "CSTATE" , "DSTATE" } ; static const char_T * rt_LoggedStateBlockNames [ ] = { "sliding_mode/Varying State Space/State" , "sliding_mode/Delay" } ; static const char_T * rt_LoggedStateNames [ ] = { "" , "DSTATE" } ; static boolean_T rt_LoggedStateCrossMdlRef [ ] = { 0 , 0 } ; static RTWLogDataTypeConvert rt_RTWLogDataTypeConvert [ ] = { { 0 , SS_DOUBLE , SS_DOUBLE , 0 , 0 , 0 , 1.0 , 0 , 0.0 } , { 0 , SS_DOUBLE , SS_DOUBLE , 0 , 0 , 0 , 1.0 , 0 , 0.0 } } ; static int_T rt_LoggedStateIdxList [ ] = { 0 , 0 } ; static RTWLogSignalInfo rt_LoggedStateSignalInfo = { 2 , rt_LoggedStateWidths , rt_LoggedStateNumDimensions , rt_LoggedStateDimensions , rt_LoggedStateIsVarDims , ( NULL ) , ( NULL ) , rt_LoggedStateDataTypeIds , rt_LoggedStateComplexSignals , ( NULL ) , rt_LoggingStatePreprocessingFcnPtrs , { rt_LoggedStateLabels } , ( NULL ) , ( NULL ) , ( NULL ) , { rt_LoggedStateBlockNames } , { rt_LoggedStateNames } , rt_LoggedStateCrossMdlRef , rt_RTWLogDataTypeConvert , rt_LoggedStateIdxList } ; static void * rt_LoggedStateSignalPtrs [ 2 ] ; rtliSetLogXSignalPtrs ( ssGetRTWLogInfo ( rtS ) , ( LogSignalPtrsType ) rt_LoggedStateSignalPtrs ) ; rtliSetLogXSignalInfo ( ssGetRTWLogInfo ( rtS ) , & rt_LoggedStateSignalInfo ) ; rt_LoggedStateSignalPtrs [ 0 ] = ( void * ) & rtX . ocjgzpkjel [ 0 ] ; rt_LoggedStateSignalPtrs [ 1 ] = ( void * ) rtDW . jizccaxfkn ; } rtliSetLogT ( ssGetRTWLogInfo ( rtS ) , "tout" ) ; rtliSetLogX ( ssGetRTWLogInfo ( rtS ) , "" ) ; rtliSetLogXFinal ( ssGetRTWLogInfo ( rtS ) , "xFinal" ) ; rtliSetLogVarNameModifier ( ssGetRTWLogInfo ( rtS ) , "none" ) ; rtliSetLogFormat ( ssGetRTWLogInfo ( rtS ) , 4 ) ; rtliSetLogMaxRows ( ssGetRTWLogInfo ( rtS ) , 0 ) ; rtliSetLogDecimation ( ssGetRTWLogInfo ( rtS ) , 1 ) ; rtliSetLogY ( ssGetRTWLogInfo ( rtS ) , "" ) ; rtliSetLogYSignalInfo ( ssGetRTWLogInfo ( rtS ) , ( NULL ) ) ; rtliSetLogYSignalPtrs ( ssGetRTWLogInfo ( rtS ) , ( NULL ) ) ; } { static struct _ssStatesInfo2 statesInfo2 ; ssSetStatesInfo2 ( rtS , & statesInfo2 ) ; } { static ssPeriodicStatesInfo periodicStatesInfo ; ssSetPeriodicStatesInfo ( rtS , & periodicStatesInfo ) ; } { static ssJacobianPerturbationBounds jacobianPerturbationBounds ; ssSetJacobianPerturbationBounds ( rtS , & jacobianPerturbationBounds ) ; } { static ssSolverInfo slvrInfo ; static boolean_T contStatesDisabled [ 4 ] ; static real_T absTol [ 4 ] = { 1.0E-6 , 1.0E-6 , 1.0E-6 , 1.0E-6 } ; static uint8_T absTolControl [ 4 ] = { 0U , 0U , 0U , 0U } ; static real_T contStateJacPerturbBoundMinVec [ 4 ] ; static real_T contStateJacPerturbBoundMaxVec [ 4 ] ; static ssNonContDerivSigInfo nonContDerivSigInfo [ 2 ] = { { 4 * sizeof ( real_T ) , ( char * ) ( & rtB . exm13eufw3 [ 0 ] ) , ( NULL ) } , { 16 * sizeof ( real_T ) , ( char * ) ( & rtB . jbmxj2cv5i [ 0 ] ) , ( NULL ) } } ; { int i ; for ( i = 0 ; i < 4 ; ++ i ) { contStateJacPerturbBoundMinVec [ i ] = 0 ; contStateJacPerturbBoundMaxVec [ i ] = rtGetInf ( ) ; } } ssSetSolverRelTol ( rtS , 0.001 ) ; ssSetStepSize ( rtS , 0.0 ) ; ssSetMinStepSize ( rtS , 0.0 ) ; ssSetMaxNumMinSteps ( rtS , - 1 ) ; ssSetMinStepViolatedError ( rtS , 0 ) ; ssSetMaxStepSize ( rtS , 1.0 ) ; ssSetSolverMaxOrder ( rtS , - 1 ) ; ssSetSolverRefineFactor ( rtS , 1 ) ; ssSetOutputTimes ( rtS , ( NULL ) ) ; ssSetNumOutputTimes ( rtS , 0 ) ; ssSetOutputTimesOnly ( rtS , 0 ) ; ssSetOutputTimesIndex ( rtS , 0 ) ; ssSetZCCacheNeedsReset ( rtS , 0 ) ; ssSetDerivCacheNeedsReset ( rtS , 0 ) ; ssSetNumNonContDerivSigInfos ( rtS , 2 ) ; ssSetNonContDerivSigInfos ( rtS , nonContDerivSigInfo ) ; ssSetSolverInfo ( rtS , & slvrInfo ) ; ssSetSolverName ( rtS , "VariableStepAuto" ) ; ssSetVariableStepSolver ( rtS , 1 ) ; ssSetSolverConsistencyChecking ( rtS , 0 ) ; ssSetSolverAdaptiveZcDetection ( rtS , 0 ) ; ssSetSolverRobustResetMethod ( rtS , 0 ) ; ssSetAbsTolVector ( rtS , absTol ) ; ssSetAbsTolControlVector ( rtS , absTolControl ) ; ssSetSolverAbsTol_Obsolete ( rtS , absTol ) ; ssSetSolverAbsTolControl_Obsolete ( rtS , absTolControl ) ; ssSetJacobianPerturbationBoundsMinVec ( rtS , contStateJacPerturbBoundMinVec ) ; ssSetJacobianPerturbationBoundsMaxVec ( rtS , contStateJacPerturbBoundMaxVec ) ; ssSetSolverStateProjection ( rtS , 0 ) ; ssSetSolverMassMatrixType ( rtS , ( ssMatrixType ) 0 ) ; ssSetSolverMassMatrixNzMax ( rtS , 0 ) ; ssSetModelOutputs ( rtS , MdlOutputs ) ; ssSetModelUpdate ( rtS , MdlUpdate ) ; ssSetModelDerivatives ( rtS , MdlDerivatives ) ; ssSetSolverMaxConsecutiveMinStep ( rtS , 1 ) ; ssSetSolverShapePreserveControl ( rtS , 2 ) ; ssSetTNextTid ( rtS , INT_MIN ) ; ssSetTNext ( rtS , rtMinusInf ) ; ssSetSolverNeedsReset ( rtS ) ; ssSetNumNonsampledZCs ( rtS , 0 ) ; ssSetContStateDisabled ( rtS , contStatesDisabled ) ; ssSetSolverMaxConsecutiveMinStep ( rtS , 1 ) ; } ssSetChecksumVal ( rtS , 0 , 2096759775U ) ; ssSetChecksumVal ( rtS , 1 , 2439401993U ) ; ssSetChecksumVal ( rtS , 2 , 1016586332U ) ; ssSetChecksumVal ( rtS , 3 , 2257312720U ) ; { static const sysRanDType rtAlwaysEnabled = SUBSYS_RAN_BC_ENABLE ; static RTWExtModeInfo rt_ExtModeInfo ; static const sysRanDType * systemRan [ 3 ] ; gblRTWExtModeInfo = & rt_ExtModeInfo ; ssSetRTWExtModeInfo ( rtS , & rt_ExtModeInfo ) ; rteiSetSubSystemActiveVectorAddresses ( & rt_ExtModeInfo , systemRan ) ; systemRan [ 0 ] = & rtAlwaysEnabled ; systemRan [ 1 ] = & rtAlwaysEnabled ; systemRan [ 2 ] = & rtAlwaysEnabled ; rteiSetModelMappingInfoPtr ( ssGetRTWExtModeInfo ( rtS ) , & ssGetModelMappingInfo ( rtS ) ) ; rteiSetChecksumsPtr ( ssGetRTWExtModeInfo ( rtS ) , ssGetChecksums ( rtS ) ) ; rteiSetTPtr ( ssGetRTWExtModeInfo ( rtS ) , ssGetTPtr ( rtS ) ) ; } slsaDisallowedBlocksForSimTargetOP ( rtS , mr_sliding_mode_GetSimStateDisallowedBlocks ) ; slsaGetWorkFcnForSimTargetOP ( rtS , mr_sliding_mode_GetDWork ) ; slsaSetWorkFcnForSimTargetOP ( rtS , mr_sliding_mode_SetDWork ) ; rt_RapidReadMatFileAndUpdateParams ( rtS ) ; if ( ssGetErrorStatus ( rtS ) ) { return rtS ; } executionInfo -> simulationOptions_ . stateSaveName_ = rtliGetLogX ( ssGetRTWLogInfo ( rtS ) ) ; executionInfo -> simulationOptions_ . finalStateName_ = rtliGetLogXFinal ( ssGetRTWLogInfo ( rtS ) ) ; executionInfo -> simulationOptions_ . outputSaveName_ = rtliGetLogY ( ssGetRTWLogInfo ( rtS ) ) ; executionInfo -> simulationOptions_ . inputTimeTolerance_ = 0.0 ; return rtS ; }
#if defined(_MSC_VER)
#pragma optimize( "", on )
#endif
void MdlOutputsParameterSampleTime ( int_T tid ) { MdlOutputsTID3 ( tid ) ; }
